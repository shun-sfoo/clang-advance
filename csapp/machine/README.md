# 第三章 程序的机器级表示

PC 程序计数器， 在 `x86-64` 用 `%rip` 表示

## 前置知识

信息就是位+上下文

0 或 1 表示位又被称为比特(bit)

8 个位被组织成一组，又被成为字节(byte)

## 数据格式

| c 声明  | Intel 数据类型 | 汇编代码 | 大小（大小） |
| ------- | -------------- | -------- | ------------ |
| char    | 字节           | b        | 1            |
| short   | 字             | w        | 2            |
| int     | 双字           | l        | 4            |
| long    | 四字           | q        | 8            |
| `char*` | 四字           | q        | 8            |
| float   | 单精度         | s        | 4            |
| double  | 双精度         | l        | 8            |

### 寄存器

| 63   | 31    | 15    | 7~0   | 含义         |
| ---- | ----- | ----- | ----- | ------------ |
| %rax | %eax  | %ax   | %al   | 返回值       |
| %rbx | %ebx  | %bx   | %bl   | 被调用者保存 |
| %rcx | %ecx  | %cx   | %cl   | 第 4 个参数  |
| %rdx | %edx  | %dx   | %dl   | 第 3 个参数  |
| %rsi | esi   | %si   | %sil  | 第 2 个参数  |
| %rdi | %edi  | %di   | %dil  | 第 1 个参数  |
| %rbp | %ebp  | %bp   | %bpl  | 被调用者保存 |
| %rsp | %esp  | %sp   | %spl  | 栈指针       |
| %r8  | %r8d  | %r8w  | %r8b  | 第 5 个参数  |
| %r9  | %r9d  | %r9w  | %r9b  | 第 6 个参数  |
| %r10 | %r10d | %r10w | %r10b | 调用者保存   |
| %r11 | %r11d | %r11w | %r11b | 调用者保存   |
| %r12 | %r12d | %r12w | %r12b | 被调用者保存 |
| %r13 | %r13d | %r13w | %r13b | 被调用者保存 |
| %r14 | %r14d | %r14w | %r14b | 被调用者保存 |
| %r15 | %r15d | %r15w | %r15b | 被调用者保存 |

指令可以对这 16 个寄存器的低位字节中存放的不同大小的数据进行操作。
字节级的操作可以访问最低的字节, 16 位操作可以反问最低的 2 个字节，
32 位操作可以访问最低的 4 个字节，而 64 位操作可以访问整个寄存器。

对于生成小于 8 字节结果的指令，寄存器剩下的字节会怎么样，对此有两条规则：
生成 1 字节和 2 字节数字的指令会保持剩下的字节不变；生成 4 字节数字的指令会把
高位 4 个字节置为 0。

### 传送指令

将数据从一个位置复制到另一个位置的指令。

#### MOV

源操作数指定的值是一个立即数，存储在寄存器或者内存中。目的操作数指定一个位置，
要么是一个寄存器，要么是一个内存地址。x86-64 加了一条限制，传送指令的两个操作数
不能都指向内存位置。将一个值从一个内存地址复制到另一个内存地址需要两条指令：
第一条指令将源值加载到寄存器，第二条将该寄存器的值写入目的位置。
寄存器部分的大小必须与指令最后一个字符指定的大小匹配。大多数情况中，
MOV 指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是
movl 指令以寄存器作为目的时，它会把该寄存器的高 4 字节设置为 0。造成整个例外
的原因是 x86-64 采用的惯例，即任何为寄存器生成 32 位值的指令都会把该寄存器的高位部分置成 0。

#### leaq 加载有效地址

leaq 实际上是 moveq 指令的变形。他的指令形式是从内存读数据到寄存器，
但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，
但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的的操作数。
用 C 语言中的地址操作符 `&s`说明这种计算。这条指令可以为后面的内存引用产生指针。
目的操作数必须是一个寄存器。

#### 一元操作和二元操作

一元操作只有一个操作数，既是源又是目的，这个操作数可以是一个寄存器，
也可以是一个内存位置。
二元操作，第二个操作数既是源又是目的，第一个操作数可以是立即数，寄存器或是内存位置。
第二个操作数可以是寄存器或是内存位置。第二个数为内存地址时，处理器必须从内存读出值，
执行操作，再把结果写回内存。
移位操作，先给出移位量，第二项给出要移位的数。

## 控制

### 条件码

CF:进位标志。
ZF:零标志。
SF:符号标志。
OF:溢出标志。

### 条件传送指令

每条指令都有两个操作数：源寄存器或者内存地址 S
和目的寄存器 R , 与 set 和跳转指令这些指令的结果
取决于条件码的值。源值可以从内存或者源寄存器中读取，
但只有在指定的条件满足时，才会被复制到目的的寄存器中。
